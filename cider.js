// Generated by CoffeeScript 1.4.0

/*
#
# Copyright Â© 2013 Paul Straw <paulstraw@paulstraw.com>
#
# Permission is hereby granted, free of charge, to any
# person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the
# Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute,
# sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice
# shall be included in all copies or substantial portions
# of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
# ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
# PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
*/


/* --------------------------------------------
     Begin init.coffee
--------------------------------------------
*/


(function() {
  var Animation, Cider, Clock, Entity, Game, GameController, Level, LevelLoader, Loader, Map, PlatformerEntity, SpriteSheet, ciderKeys,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    _this = this,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Audio.prototype.stop = function() {
    this.pause();
    return this.currentTime = 0;
  };

  Audio.prototype.trigger = function() {
    this.stop();
    return this.play();
  };

  /* --------------------------------------------
       Begin loader.coffee
  --------------------------------------------
  */


  Loader = (function() {

    function Loader(parent, resources, resourcesPrefix) {
      var key, val, _ref;
      this.parent = parent;
      this.resources = resources != null ? resources : {};
      this.resourcesPrefix = resourcesPrefix != null ? resourcesPrefix : '';
      this._updateComplete = __bind(this._updateComplete, this);

      this._imageError = __bind(this._imageError, this);

      this._imageLoaded = __bind(this._imageLoaded, this);

      this._soundError = __bind(this._soundError, this);

      this._soundLoaded = __bind(this._soundLoaded, this);

      this._loadSound = __bind(this._loadSound, this);

      this._initializeResource = __bind(this._initializeResource, this);

      this.percentComplete = 0;
      this.completed = 0;
      this.resourceCount = Object.keys(this.resources).length;
      _ref = this.resources;
      for (key in _ref) {
        val = _ref[key];
        this._initializeResource(key, val);
      }
    }

    Loader.prototype._initializeResource = function(key, val) {
      var audioElement, imgElement, resourceUrl, sourceElement, _i, _len;
      if (Array.isArray(val)) {
        audioElement = new Audio();
        for (_i = 0, _len = val.length; _i < _len; _i++) {
          resourceUrl = val[_i];
          sourceElement = document.createElement('source');
          sourceElement.src = this.resourcesPrefix + resourceUrl;
          audioElement.appendChild(sourceElement);
        }
        audioElement.addEventListener('canplaythrough', this._soundLoaded);
        audioElement.addEventListener('error', this._soundError);
        this._loadSound(audioElement);
        return this.resources[key] = audioElement;
      } else {
        imgElement = new Image();
        imgElement.addEventListener('load', this._imageLoaded);
        imgElement.addEventListener('error', this._imageError);
        imgElement.src = this.resourcesPrefix + val;
        return this.resources[key] = imgElement;
      }
    };

    Loader.prototype._loadSound = function(el) {
      document.body.appendChild(el);
      el.volume = 0;
      return el.play();
    };

    Loader.prototype._soundLoaded = function(e) {
      var el;
      el = e.target;
      el.pause();
      el.currentTime = 0;
      el.removeEventListener('canplaythrough', this._soundLoad);
      el.removeEventListener('error', this._soundError);
      return this._updateComplete();
    };

    Loader.prototype._soundError = function(e) {
      var el, src;
      el = e.target;
      el.removeEventListener('canplaythrough', this._soundLoad);
      el.removeEventListener('error', this._soundError);
      src = el.firstChild.src;
      throw new Error("" + (src.substr(0, src.lastIndexOf('.'))) + " failed to load.");
      return this._updateComplete();
    };

    Loader.prototype._imageLoaded = function(e) {
      var el;
      el = e.target;
      el.removeEventListener('load', this._imageLoaded);
      el.removeEventListener('error', this._imageError);
      return this._updateComplete();
    };

    Loader.prototype._imageError = function(e) {
      var el;
      el = e.target;
      el.removeEventListener('load', this._imageLoaded);
      el.removeEventListener('error', this._imageError);
      throw new Error("" + el.src + " failed to load.");
    };

    Loader.prototype._updateComplete = function() {
      var el, name, _ref, _ref1;
      this.completed++;
      this.percentComplete = Math.round(this.completed / this.resourceCount * 100);
      if (this.percentComplete === 100) {
        _ref = this.resources;
        for (name in _ref) {
          el = _ref[name];
          if (el.tagName === 'AUDIO') {
            el.volume = 1;
          }
        }
        return (_ref1 = this.parent) != null ? typeof _ref1.ready === "function" ? _ref1.ready() : void 0 : void 0;
      }
    };

    return Loader;

  })();

  /* --------------------------------------------
       Begin clock.coffee
  --------------------------------------------
  */


  Clock = (function() {

    Clock.prototype.maxStep = 50;

    Clock.prototype.timeScale = 1;

    function Clock(target) {
      this.target = target != null ? target : 0;
      this.delta = __bind(this.delta, this);

      this.tick = __bind(this.tick, this);

      this.reset = __bind(this.reset, this);

      this.set = __bind(this.set, this);

      this.base = c.Clock.time;
      this.last = c.Clock.time;
    }

    Clock.prototype.set = function(target) {
      this.target = target || 0;
      return this.base = c.Clock.time;
    };

    Clock.prototype.reset = function() {
      return this.base = c.Clock.time;
    };

    Clock.prototype.tick = function() {
      var delta;
      delta = c.Clock.time - this.last;
      this.last = c.Clock.time;
      return delta;
    };

    Clock.prototype.delta = function() {
      return c.Clock.time - this.base - this.target;
    };

    return Clock;

  })();

  Clock.maxStep = 50;

  Clock.timeScale = 1;

  Clock.time = 0;

  Clock._last = 0;

  Clock.step = function() {
    var current, delta;
    current = Date.now();
    delta = current - c.Clock._last;
    c.Clock.time += Math.min(delta, c.Clock.maxStep) * c.Clock.timeScale;
    return c.Clock._last = current;
  };

  /* --------------------------------------------
       Begin map.coffee
  --------------------------------------------
  */


  Map = (function() {

    function Map(data, options) {
      this.data = data;
      if (options == null) {
        options = {};
      }
      if (!this.data) {
        throw new Error('Cider Maps require an array containing map data');
      }
      this.type = c.mapType.regular;
      this.distance = 1;
      c.extend(this, options);
      if (this.type !== c.mapType.collision && !this.tileset) {
        throw new Error('Non-collision Cider Maps require a tileset.');
      }
    }

    return Map;

  })();

  /* --------------------------------------------
       Begin level.coffee
  --------------------------------------------
  */


  Level = (function() {

    function Level(game, options) {
      var map, _i, _len, _ref;
      this.game = game;
      if (options == null) {
        options = {};
      }
      this.addMap = __bind(this.addMap, this);

      this.setPxSize = __bind(this.setPxSize, this);

      this.size = {
        x: 50,
        y: 25
      };
      this.tileSize = 32;
      this.maps = [];
      c.extend(this, options);
      _ref = this.maps;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        map = _ref[_i];
        this.addMap(map);
      }
      this.setPxSize();
    }

    Level.prototype.setPxSize = function() {
      return this.pxSize = {
        x: this.size.x * this.tileSize,
        y: this.size.y * this.tileSize
      };
    };

    Level.prototype.addMap = function(map) {
      var _ref;
      return (_ref = map.tileSize) != null ? _ref : map.tileSize = this.tileSize;
    };

    return Level;

  })();

  /* --------------------------------------------
       Begin animation.coffee
  --------------------------------------------
  */


  SpriteSheet = (function() {

    function SpriteSheet(image, frameWidth, frameHeight) {
      this.image = image;
      this.frameWidth = frameWidth != null ? frameWidth : 16;
      this.frameHeight = frameHeight != null ? frameHeight : 16;
      this.src = this.image.src;
    }

    return SpriteSheet;

  })();

  Animation = (function() {

    function Animation(spriteSheet, frameLength, sequence) {
      var img;
      this.spriteSheet = spriteSheet;
      this.frameLength = frameLength;
      this.sequence = sequence != null ? sequence : [0];
      this.draw = __bind(this.draw, this);

      this.update = __bind(this.update, this);

      spriteSheet = this.spriteSheet;
      img = spriteSheet.image;
      this.src = spriteSheet.image.src;
      this.width = spriteSheet.frameWidth;
      this.height = spriteSheet.frameHeight;
      this.tilesPerRow = img.width / this.width;
      this.offset = {
        x: 0,
        y: 0
      };
      this.imgWidth = img.width;
      this.imgHeight = img.height;
      this.clock = new c.Clock;
    }

    Animation.prototype.update = function() {
      var currentColumn, currentRow, frameTotal;
      frameTotal = Math.floor(this.clock.delta() / this.frameLength);
      this.frame = frameTotal % this.sequence.length;
      this.tile = this.sequence[this.frame];
      currentRow = Math.ceil((this.tile + 1) / this.tilesPerRow) - 1;
      currentColumn = this.tile % this.tilesPerRow;
      this.offset.x = -(currentColumn * this.width);
      return this.offset.y = -(currentRow * this.height);
    };

    Animation.prototype.draw = function(entity) {
      return entity.el.style.backgroundPosition = "" + this.offset.x + "px " + this.offset.y + "px";
    };

    return Animation;

  })();

  /* --------------------------------------------
       Begin gamecontroller.coffee
  --------------------------------------------
  */


  GameController = (function() {

    function GameController(game) {
      this.game = game;
      this.holding = __bind(this.holding, this);

      this.triggered = __bind(this.triggered, this);

      this._keyup = __bind(this._keyup, this);

      this._keydown = __bind(this._keydown, this);

      this.update = __bind(this.update, this);

      this.detach = __bind(this.detach, this);

      this.attach = __bind(this.attach, this);

      this._triggered = {};
      this._holding = {};
      this._attached = {};
      this.game.el.addEventListener('keydown', this._keydown, false);
      this.game.el.addEventListener('keyup', this._keyup, false);
    }

    GameController.prototype.attach = function(key, action) {
      return this._attached[key] = action;
    };

    GameController.prototype.detach = function(key) {
      return delete this.attached[key];
    };

    GameController.prototype.update = function() {
      return this._triggered = {};
    };

    GameController.prototype._keydown = function(e) {
      var action;
      action = this._attached[e.keyCode];
      if (action && !this._holding[action]) {
        this._triggered[action] = true;
        this._holding[action] = true;
      }
      e.stopPropagation();
      return e.preventDefault();
    };

    GameController.prototype._keyup = function(e) {
      var action;
      action = this._attached[e.keyCode];
      if (action) {
        return delete this._holding[action];
      }
    };

    GameController.prototype.triggered = function(action) {
      return this._triggered[action];
    };

    GameController.prototype.holding = function(action) {
      return this._holding[action];
    };

    return GameController;

  })();

  ciderKeys = {
    'm1': -1,
    'm2': -3,
    'mup': -4,
    'mdown': -5,
    'backspace': 8,
    'tab': 9,
    'enter': 13,
    'pause': 19,
    'caps': 20,
    'esc': 27,
    'space': 32,
    'page up': 33,
    'page down': 34,
    'end': 35,
    'home': 36,
    'left': 37,
    'up': 38,
    'right': 39,
    'down': 40,
    'insert': 45,
    'delete': 46,
    '_0': 48,
    '_1': 49,
    '_2': 50,
    '_3': 51,
    '_4': 52,
    '_5': 53,
    '_6': 54,
    '_7': 55,
    '_8': 56,
    '_9': 57,
    'a': 65,
    'b': 66,
    'c': 67,
    'd': 68,
    'e': 69,
    'f': 70,
    'g': 71,
    'h': 72,
    'i': 73,
    'j': 74,
    'k': 75,
    'l': 76,
    'm': 77,
    'n': 78,
    'o': 79,
    'p': 80,
    'q': 81,
    'r': 82,
    's': 83,
    't': 84,
    'u': 85,
    'v': 86,
    'w': 87,
    'x': 88,
    'y': 89,
    'z': 90,
    'num 0': 96,
    'numpad 1': 97,
    'numpad 2': 98,
    'numpad 3': 99,
    'numpad 4': 100,
    'numpad 5': 101,
    'numpad 6': 102,
    'numpad 7': 103,
    'numpad 8': 104,
    'numpad 9': 105,
    'multiply': 106,
    'add': 107,
    'subtract': 109,
    'decimal': 110,
    'divide': 111,
    'f1': 112,
    'f2': 113,
    'f3': 114,
    'f4': 115,
    'f5': 116,
    'f6': 117,
    'f7': 118,
    'f8': 119,
    'f9': 120,
    'f10': 121,
    'f11': 122,
    'f12': 123,
    'shift': 16,
    'ctrl': 17,
    'alt': 18,
    'plus': 187,
    'comma': 188,
    'minus': 189,
    'period': 190
  };

  /* --------------------------------------------
       Begin levelLoader.coffee
  --------------------------------------------
  */


  LevelLoader = (function() {

    function LevelLoader(game) {
      this.game = game;
      this.createMapTile = __bind(this.createMapTile, this);

      this.createMapBody = __bind(this.createMapBody, this);

      this.loadMap = __bind(this.loadMap, this);

      this.load = __bind(this.load, this);

      if (!this.game) {
        throw new Error('LevelLoader must be passed a `Game`.');
      }
    }

    LevelLoader.prototype.load = function(level) {
      var map, _i, _len, _ref, _results;
      _ref = level.maps;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        map = _ref[_i];
        _results.push(this.loadMap(map));
      }
      return _results;
    };

    LevelLoader.prototype.loadMap = function(map) {
      var col, i, img, j, mapContainer, mcs, row, tileSize, tilesPerRow, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _results;
      if (map.type === c.mapType.collision) {
        _ref = map.data;
        _results = [];
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          row = _ref[i];
          _results.push((function() {
            var _j, _len1, _results1;
            _results1 = [];
            for (j = _j = 0, _len1 = row.length; _j < _len1; j = ++_j) {
              col = row[j];
              _results1.push(this.createMapBody(map, row[j], i, j));
            }
            return _results1;
          }).call(this));
        }
        return _results;
      } else if (map.type === c.mapType.regular) {
        mapContainer = document.createElement('div');
        img = map.tileset;
        tileSize = map.tileSize;
        tilesPerRow = img.width / tileSize;
        mapContainer.className = 'cider-map';
        mapContainer.setAttribute('data-distance', map.distance);
        mcs = mapContainer.style;
        mcs.position = 'absolute';
        mcs.left = '0px';
        mcs.top = '0px';
        _ref1 = map.data;
        for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
          row = _ref1[i];
          for (j = _k = 0, _len2 = row.length; _k < _len2; j = ++_k) {
            col = row[j];
            this.createMapTile(mapContainer, map, row[j], i, j, img, tileSize, tilesPerRow);
          }
        }
        return this.game.el.appendChild(mapContainer);
      }
    };

    LevelLoader.prototype.createMapBody = function(map, tile, row, col) {
      var body, bodyDef, fixtureDef, tileSize, xPos, yPos;
      if (!tile) {
        return;
      }
      tileSize = map.tileSize;
      xPos = col * tileSize;
      yPos = row * tileSize;
      bodyDef = new b2BodyDef;
      bodyDef.position = new b2Vec2((xPos + tileSize / 2) / c.b2Scale, (yPos + tileSize / 2) / c.b2Scale);
      bodyDef.type = b2Body.b2_staticBody;
      body = this.game.world.CreateBody(bodyDef);
      fixtureDef = new b2FixtureDef;
      fixtureDef.density = 2;
      fixtureDef.friction = 1;
      fixtureDef.restitution = 0;
      fixtureDef.shape = new b2PolygonShape;
      fixtureDef.shape.SetAsBox(tileSize / 2 / c.b2Scale, tileSize / 2 / c.b2Scale);
      return body.CreateFixture(fixtureDef);
    };

    LevelLoader.prototype.createMapTile = function(mapContainer, map, tile, row, col, img, tileSize, tilesPerRow) {
      var currentColumn, currentRow, offX, offY, tcStyle, tileContainer, xPos, yPos;
      if (!tile) {
        return;
      }
      tileSize = map.tileSize;
      xPos = col * tileSize;
      yPos = row * tileSize;
      tileContainer = document.createElement('div');
      tcStyle = tileContainer.style;
      currentRow = Math.ceil(tile / tilesPerRow) - 1;
      currentColumn = tile % tilesPerRow - 1;
      offX = -(currentColumn * tileSize);
      offY = -(currentRow * tileSize);
      tcStyle.width = tcStyle.height = "" + tileSize + "px";
      tcStyle.position = 'absolute';
      tcStyle.left = "" + xPos + "px";
      tcStyle.top = "" + yPos + "px";
      tcStyle.backgroundImage = "url(" + img.src + ")";
      tcStyle.backgroundPosition = "" + offX + "px " + offY + "px";
      tcStyle.zIndex = map.zIndex || 1;
      return mapContainer.appendChild(tileContainer);
    };

    return LevelLoader;

  })();

  /* --------------------------------------------
       Begin game.coffee
  --------------------------------------------
  */


  Game = (function() {

    function Game(options) {
      if (options == null) {
        options = {};
      }
      this.destroyEntity = __bind(this.destroyEntity, this);

      this.createEntity = __bind(this.createEntity, this);

      this.drawEntities = __bind(this.drawEntities, this);

      this.updateEntities = __bind(this.updateEntities, this);

      this.draw = __bind(this.draw, this);

      this.update = __bind(this.update, this);

      this.run = __bind(this.run, this);

      this.unpause = __bind(this.unpause, this);

      this.pause = __bind(this.pause, this);

      this.ready = __bind(this.ready, this);

      this.loadLevel = __bind(this.loadLevel, this);

      this.positionCamera = __bind(this.positionCamera, this);

      this.initializeElements = __bind(this.initializeElements, this);

      this.getEntityById = __bind(this.getEntityById, this);

      this.createElements = __bind(this.createElements, this);

      this.initializeCollisionListeners = __bind(this.initializeCollisionListeners, this);

      this.initializeDebugMode = __bind(this.initializeDebugMode, this);

      this._entityIdCounter = 1;
      this.clock = new c.Clock;
      this.levelLoader = new c.LevelLoader(this);
      this.entities = {};
      if (this.resources == null) {
        this.resources = {};
      }
      this.cSize = {
        x: 640,
        y: 320
      };
      this.tagName = 'div';
      this.className = '';
      this.id = 'cider-camera';
      this.gravity = {
        x: 0,
        y: 9.8
      };
      this.cPos = {
        x: 0,
        y: 0
      };
      this.debug = false;
      this.debugDraw = false;
      c.extend(this, options);
      this.bodyTrash = [];
      this.createElements();
      this.initializeElements();
      this.controller = new c.GameController(this);
      this.loader = new c.Loader(this, this.resources);
      if (this.debug) {
        this.initializeDebugMode();
        this.lastFrameStart = Date.now();
      }
      if (this.debugDraw) {
        this.debugCanvas = document.createElement('canvas');
        document.body.appendChild(this.debugCanvas);
      }
      this.run();
    }

    Game.prototype.initializeDebugMode = function() {
      var style;
      this.debugEl = document.createElement('div');
      style = this.debugEl.style;
      this.debugEl.id = 'cider-debug';
      style.position = 'absolute';
      style.bottom = '0px';
      style.right = '0px';
      return document.body.appendChild(this.debugEl);
    };

    Game.prototype.initializeCollisionListeners = function() {
      var listener,
        _this = this;
      listener = new b2ContactListener;
      listener.BeginContact = function(contact) {
        var eA, eB;
        eA = _this.entities[contact.GetFixtureA().GetBody().GetUserData()];
        eB = _this.entities[contact.GetFixtureB().GetBody().GetUserData()];
        if (eA) {
          eA.contactBegin(contact);
        }
        if (eB) {
          return eB.contactBegin(contact);
        }
      };
      listener.EndContact = function(contact) {
        var eA, eB;
        eA = _this.entities[contact.GetFixtureA().GetBody().GetUserData()];
        eB = _this.entities[contact.GetFixtureB().GetBody().GetUserData()];
        if (eA) {
          eA.contactEnd(contact);
        }
        if (eB) {
          return eB.contactEnd(contact);
        }
      };
      listener.PreSolve = function(contact, oldManifold) {};
      listener.PostSolve = function(contact, impulse) {
        var eA, eB;
        eA = _this.entities[contact.GetFixtureA().GetBody().GetUserData()];
        eB = _this.entities[contact.GetFixtureB().GetBody().GetUserData()];
        if (eA && eB) {
          eA.collidePost(eB, impulse.normalImpulses[0]);
          return eB.collidePost(eA, impulse.normalImpulses[0]);
        }
      };
      return this.world.SetContactListener(listener);
    };

    Game.prototype.createElements = function() {
      var cameraEl, el;
      cameraEl = document.createElement('div');
      cameraEl.id = this.id;
      cameraEl.className = this.className;
      this.cameraEl = cameraEl;
      el = document.createElement(this.tagName);
      el.id = 'cider-world';
      el.setAttribute('tabindex', '1');
      return this.el = el;
    };

    Game.prototype.getEntityById = function(id) {
      var eId, entity, match, _ref;
      match = null;
      _ref = this.entities;
      for (eId in _ref) {
        entity = _ref[eId];
        if (entity.id === id) {
          match = entity;
        }
      }
      return match;
    };

    Game.prototype.initializeElements = function() {
      var cEs, es;
      cEs = this.cameraEl.style;
      cEs.width = "" + this.cSize.x + "px";
      cEs.height = "" + this.cSize.y + "px";
      cEs.overflow = 'hidden';
      cEs.position = 'relative';
      es = this.el.style;
      es.overflow = 'hidden';
      es.position = 'absolute';
      document.body.appendChild(this.cameraEl);
      return this.cameraEl.appendChild(this.el);
    };

    Game.prototype.positionCamera = function() {
      var distance, es, map, maps, ms, _i, _len, _results;
      if (!this.currentLevel) {
        return;
      }
      es = this.el.style;
      if (this.cPos.x < 0) {
        this.cPos.x = 0;
      }
      if (this.cPos.x > this.currentLevel.pxSize.x - this.cSize.x) {
        this.cPos.x = this.currentLevel.pxSize.x - this.cSize.x;
      }
      if (this.cPos.y < 0) {
        this.cPos.y = 0;
      }
      if (this.cPos.y > this.currentLevel.pxSize.y - this.cSize.y) {
        this.cPos.y = this.currentLevel.pxSize.y - this.cSize.y;
      }
      es.left = "" + (-this.cPos.x) + "px";
      es.top = "" + (-this.cPos.y) + "px";
      maps = this.el.getElementsByClassName('cider-map');
      _results = [];
      for (_i = 0, _len = maps.length; _i < _len; _i++) {
        map = maps[_i];
        distance = parseInt(map.getAttribute('data-distance'), 10);
        if (distance !== 1) {
          ms = map.style;
          ms.left = "" + (this.cPos.x / distance) + "px";
          _results.push(ms.top = "" + (this.cPos.y / distance) + "px");
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Game.prototype.loadLevel = function(level) {
      var debugDraw, es;
      this.world = new b2World(new b2Vec2(this.gravity.x, this.gravity.y), true);
      this.el.innerHTML = '';
      this.initializeCollisionListeners();
      this.currentLevel = level;
      this.cPos = {
        x: 0,
        y: 0
      };
      es = this.el.style;
      es.width = "" + (level.size.x * level.tileSize) + "px";
      es.height = "" + (level.size.y * level.tileSize) + "px";
      if (this.debugDraw) {
        this.debugCanvas.width = level.pxSize.x;
        this.debugCanvas.height = level.pxSize.y;
        debugDraw = new Box2D.Dynamics.b2DebugDraw;
        debugDraw.SetSprite(this.debugCanvas.getContext("2d"));
        debugDraw.SetDrawScale(c.b2Scale);
        debugDraw.SetFillAlpha(0.3);
        debugDraw.SetLineThickness(1);
        debugDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit);
        this.world.SetDebugDraw(debugDraw);
      }
      return this.levelLoader.load(level);
    };

    Game.prototype.ready = function() {};

    Game.prototype.pause = function() {
      return this.paused = true;
    };

    Game.prototype.unpause = function() {
      return this.paused = false;
    };

    Game.prototype.run = function() {
      c.raf(this.run);
      c.Clock.step();
      this.tick = this.clock.tick();
      if (this.paused) {
        return;
      }
      if (this.debug) {
        this.fps = Math.round(1 / ((Date.now() - this.lastFrameStart) / 1000));
        this.lastFrameStart = Date.now();
      }
      this.update();
      this.draw();
      if (this.debug && ~~(Math.random() * 30) === 4) {
        return this.debugEl.innerText = "" + this.fps + " FPS";
      }
    };

    Game.prototype.update = function() {
      var body, _i, _len, _ref;
      if (this.world) {
        _ref = this.bodyTrash;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          body = _ref[_i];
          this.world.DestroyBody(body);
        }
        this.world.Step(this.tick / 1000, 8, 3);
        this.world.ClearForces();
        if (this.debugDraw) {
          this.world.DrawDebugData();
        }
      }
      this.updateEntities();
      this.positionCamera();
      return this.controller.update();
    };

    Game.prototype.draw = function() {
      return this.drawEntities();
    };

    Game.prototype.updateEntities = function() {
      var eId, entity, _ref, _results;
      _ref = this.entities;
      _results = [];
      for (eId in _ref) {
        entity = _ref[eId];
        _results.push(entity.update());
      }
      return _results;
    };

    Game.prototype.drawEntities = function() {
      var eId, entity, _ref, _results;
      _ref = this.entities;
      _results = [];
      for (eId in _ref) {
        entity = _ref[eId];
        _results.push(entity.draw());
      }
      return _results;
    };

    Game.prototype.createEntity = function(entity) {
      var eId;
      eId = "e" + (this._entityIdCounter++);
      this.entities[eId] = entity;
      return eId;
    };

    Game.prototype.destroyEntity = function(entity) {
      this.bodyTrash.push(entity.body);
      return delete this.entities[entity._entityId];
    };

    return Game;

  })();

  /* --------------------------------------------
       Begin entity.coffee
  --------------------------------------------
  */


  Entity = (function() {

    function Entity(game, options) {
      this.game = game;
      if (options == null) {
        options = {};
      }
      this.setStyle = __bind(this.setStyle, this);

      this.draw = __bind(this.draw, this);

      this._destroyElement = __bind(this._destroyElement, this);

      this.destroy = __bind(this.destroy, this);

      this.contactEnd = __bind(this.contactEnd, this);

      this.contactBegin = __bind(this.contactBegin, this);

      this.collidePre = __bind(this.collidePre, this);

      this.collidePost = __bind(this.collidePost, this);

      this.update = __bind(this.update, this);

      this.setAnim = __bind(this.setAnim, this);

      this.drawElement = __bind(this.drawElement, this);

      this.initializeElement = __bind(this.initializeElement, this);

      this.createElement = __bind(this.createElement, this);

      this.createBody = __bind(this.createBody, this);

      this._entityId = this.game.createEntity(this);
      this.tagName = 'div';
      this.className = '';
      this.id = '';
      this.pos = {
        x: 0,
        y: 0
      };
      this.vel = {
        x: 0,
        y: 0
      };
      this.zIndex = 99;
      this.size = {
        x: 0,
        y: 0
      };
      this.angle = 0;
      this.angularDamping = 0;
      this.linearDamping = 0;
      this.gravityScale = 1;
      if (this.fixedRotation == null) {
        this.fixedRotation = false;
      }
      this.bodyType = b2Body.b2_dynamicBody;
      this.density = 1;
      if (this.restitution == null) {
        this.restitution = 0;
      }
      if (this.friction == null) {
        this.friction = 0.5;
      }
      c.extend(this, options);
      this.createBody();
      this.createElement();
      this.initializeElement();
    }

    Entity.prototype.createBody = function() {
      var bodyDef, fixtureDef;
      bodyDef = new b2BodyDef;
      bodyDef.position = new b2Vec2((this.pos.x + this.size.x / 2) / c.b2Scale, (this.pos.y + this.size.y / 2) / c.b2Scale);
      bodyDef.type = this.bodyType;
      bodyDef.userData = this._entityId;
      bodyDef.angularDamping = this.angularDamping;
      bodyDef.linearDamping = this.linearDamping;
      bodyDef.gravityScale = this.gravityScale;
      bodyDef.fixedRotation = this.fixedRotation;
      this.body = this.game.world.CreateBody(bodyDef);
      fixtureDef = new b2FixtureDef;
      fixtureDef.density = this.density;
      fixtureDef.friction = this.friction;
      fixtureDef.restitution = this.restitution;
      fixtureDef.shape = new b2PolygonShape;
      fixtureDef.shape.SetAsBox(this.size.x / 2 / c.b2Scale, this.size.y / 2 / c.b2Scale);
      return this.body.CreateFixture(fixtureDef);
    };

    Entity.prototype.createElement = function() {
      var el;
      el = document.createElement(this.tagName);
      el.className = this.className;
      el.id = this.id;
      return this.el = el;
    };

    Entity.prototype.initializeElement = function() {
      var es;
      es = this.el.style;
      es.position = 'absolute';
      es.zIndex = this.zIndex;
      return this.game.el.appendChild(this.el);
    };

    Entity.prototype.drawElement = function() {
      var es;
      es = this.el.style;
      es.left = "" + (this.pos.x - this.size.x / 2) + "px";
      es.top = "" + (this.pos.y - this.size.y / 2) + "px";
      es.width = "" + this.size.x + "px";
      es.height = "" + this.size.y + "px";
      return es.WebkitTransform = "rotate(" + this.angle + "deg)";
    };

    Entity.prototype.setAnim = function(anim) {
      this.currentAnim = anim;
      return this.el.style.backgroundImage = "url(" + anim.src + ")";
    };

    Entity.prototype.update = function() {
      var body, newPos, newVel;
      body = this.body;
      newPos = body.GetPosition();
      newVel = body.GetLinearVelocity();
      if (this.currentAnim) {
        this.currentAnim.update();
      }
      this.angle = body.GetAngle() * (180 / Math.PI);
      this.pos.x = Math.round(newPos.x * c.b2Scale);
      this.pos.y = Math.round(newPos.y * c.b2Scale);
      this.vel.x = newVel.x;
      return this.vel.y = newVel.y;
    };

    Entity.prototype.collidePost = function(other, impulse) {};

    Entity.prototype.collidePre = function(contact) {};

    Entity.prototype.contactBegin = function(contact) {};

    Entity.prototype.contactEnd = function(contact) {};

    Entity.prototype.destroy = function() {
      this._destroyElement();
      return this.game.destroyEntity(this);
    };

    Entity.prototype._destroyElement = function() {
      return this.game.el.removeChild(this.el);
    };

    Entity.prototype.draw = function() {
      this.drawElement();
      if (this.currentAnim) {
        return this.currentAnim.draw(this);
      }
    };

    Entity.prototype.setStyle = function(prop, val) {
      return this.el.style[prop] = val;
    };

    return Entity;

  })();

  /* --------------------------------------------
       Begin platformerEntity.coffee
  --------------------------------------------
  */


  PlatformerEntity = (function(_super) {

    __extends(PlatformerEntity, _super);

    function PlatformerEntity() {
      this.contactEnd = __bind(this.contactEnd, this);

      this.contactBegin = __bind(this.contactBegin, this);

      this.createBody = __bind(this.createBody, this);

      this.update = __bind(this.update, this);
      this.friction = 0;
      this.restitution = 0;
      this.fixedRotation = true;
      this.standing = false;
      this.footContacts = 0;
      PlatformerEntity.__super__.constructor.apply(this, arguments);
    }

    PlatformerEntity.prototype.update = function() {
      PlatformerEntity.__super__.update.apply(this, arguments);
      return this.standing = !!this.footContacts;
    };

    PlatformerEntity.prototype.createBody = function() {
      var fixtureDef, footSensor;
      PlatformerEntity.__super__.createBody.apply(this, arguments);
      fixtureDef = new b2FixtureDef;
      fixtureDef.isSensor = true;
      fixtureDef.shape = new b2PolygonShape;
      fixtureDef.shape.SetAsOrientedBox(this.size.x / 2 / c.b2Scale - 0.02, 0.05, new b2Vec2(0.01, this.size.y / 2 / c.b2Scale));
      footSensor = this.body.CreateFixture(fixtureDef);
      return footSensor.SetUserData('cider-foot-sensor');
    };

    PlatformerEntity.prototype.contactBegin = function(contact) {
      if (contact.GetFixtureA().GetUserData() === 'cider-foot-sensor') {
        this.footContacts++;
      }
      if (contact.GetFixtureB().GetUserData() === 'cider-foot-sensor') {
        return this.footContacts++;
      }
    };

    PlatformerEntity.prototype.contactEnd = function(contact) {
      if (contact.GetFixtureA().GetUserData() === 'cider-foot-sensor') {
        this.footContacts--;
      }
      if (contact.GetFixtureB().GetUserData() === 'cider-foot-sensor') {
        return this.footContacts--;
      }
    };

    return PlatformerEntity;

  })(Entity);

  /* --------------------------------------------
       Begin cider.coffee
  --------------------------------------------
  */


  window.b2Vec2 = Box2D.Common.Math.b2Vec2;

  window.b2BodyDef = Box2D.Dynamics.b2BodyDef;

  window.b2Body = Box2D.Dynamics.b2Body;

  window.b2FixtureDef = Box2D.Dynamics.b2FixtureDef;

  window.b2Fixture = Box2D.Dynamics.b2Fixture;

  window.b2World = Box2D.Dynamics.b2World;

  window.b2MassData = Box2D.Collision.Shapes.b2MassData;

  window.b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape;

  window.b2CircleShape = Box2D.Collision.Shapes.b2CircleShape;

  window.b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape;

  window.b2DebugDraw = Box2D.Dynamics.b2DebugDraw;

  window.b2ContactListener = Box2D.Dynamics.b2ContactListener;

  window.b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef;

  Cider = {
    Loader: Loader,
    LevelLoader: LevelLoader,
    Game: Game,
    Animation: Animation,
    SpriteSheet: SpriteSheet,
    Entity: Entity,
    PlatformerEntity: PlatformerEntity,
    Clock: Clock,
    Level: Level,
    Map: Map,
    GameController: GameController,
    key: ciderKeys,
    b2Scale: 30,
    mapType: Object.freeze({
      regular: 0,
      collision: 1
    }),
    raf: (function() {
      var func;
      func = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
        return window.setTimeout(callback, 1000 / 60);
      };
      return function(cb, el) {
        return func.apply(window, [cb, el]);
      };
    })(),
    extend: function(dest) {
      var key, source, val, _i, _len, _ref;
      _ref = Array.prototype.slice.call(arguments, 1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        source = _ref[_i];
        for (key in source) {
          val = source[key];
          dest[key] = val;
        }
      }
      return dest;
    },
    log: function() {
      if (window.console) {
        return console.log(Array.prototype.slice.call(arguments));
      }
    }
  };

  window.c = window.Cider = Cider;

}).call(this);
